"""
SPICE netlist generation for circuit simulation.

Generates SPICE-compatible netlists for use with ngspice, LTspice, etc.
"""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models.circuit import Circuit


def generate_spice(
    path: str | Path | None = None,
    circuit=None,
    title: str = "sform-skidl generated netlist",
) -> str:
    """
    Generate a SPICE netlist.
    
    Args:
        path: Output file path (optional, returns string if None).
        circuit: Circuit to export (uses current if None).
        title: Netlist title comment.
        
    Returns:
        SPICE netlist as string.
        
    Example:
        generate_spice('circuit.spice')
        
        # Or get string directly
        spice_text = generate_spice()
    """
    from .api import get_circuit
    
    if circuit is None:
        circuit = get_circuit()
    
    lines = []
    lines.append(f"* {title}")
    lines.append(f"* Generated by sform-skidl")
    lines.append("")
    
    # Build net name mapping (SPICE uses node numbers or names)
    net_map = {}
    for i, net in enumerate(circuit.nets):
        if net.name.upper() in ('GND', '0', 'VSS'):
            net_map[net.name] = '0'  # SPICE ground
        else:
            net_map[net.name] = net.name.replace(' ', '_')
    
    # Generate component statements
    for part in circuit.parts:
        ref = part.ref
        prefix = ref[0].upper() if ref else 'X'
        
        # Get connected nets for each pin
        pin_nets = []
        for pin in part.pins:
            if pin.net:
                pin_nets.append(net_map.get(pin.net.name, pin.net.name))
            else:
                pin_nets.append('NC')  # Not connected
        
        # Format based on component type
        if prefix == 'R':
            # Resistor: R<name> <n1> <n2> <value>
            if len(pin_nets) >= 2:
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {part.value}")
        
        elif prefix == 'C':
            # Capacitor: C<name> <n1> <n2> <value>
            if len(pin_nets) >= 2:
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {part.value}")
        
        elif prefix == 'L':
            # Inductor: L<name> <n1> <n2> <value>
            if len(pin_nets) >= 2:
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {part.value}")
        
        elif prefix == 'D':
            # Diode: D<name> <n+> <n-> <model>
            if len(pin_nets) >= 2:
                model = part.value or 'D'
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {model}")
        
        elif prefix == 'Q':
            # Transistor: Q<name> <nc> <nb> <ne> <model>
            if len(pin_nets) >= 3:
                model = part.value or 'NPN'
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {pin_nets[2]} {model}")
        
        elif prefix == 'V':
            # Voltage source: V<name> <n+> <n-> <value>
            if len(pin_nets) >= 2:
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {part.value}")
        
        elif prefix == 'I':
            # Current source: I<name> <n+> <n-> <value>
            if len(pin_nets) >= 2:
                lines.append(f"{ref} {pin_nets[0]} {pin_nets[1]} {part.value}")
        
        else:
            # Generic subcircuit: X<name> <nodes...> <subckt>
            nodes = ' '.join(pin_nets)
            subckt = part.name or 'UNKNOWN'
            lines.append(f"X{ref} {nodes} {subckt}")
    
    lines.append("")
    lines.append(".end")
    
    spice_text = '\n'.join(lines)
    
    if path:
        path = Path(path)
        path.write_text(spice_text)
        print(f"SPICE netlist: {len(circuit.parts)} components â†’ {path}")
    
    return spice_text
